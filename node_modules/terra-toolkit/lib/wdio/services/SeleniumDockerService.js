'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _child_process = require('child_process');

var _retry = require('async/retry');

var _retry2 = _interopRequireDefault(_retry);

var _http = require('http');

var _http2 = _interopRequireDefault(_http);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _services = require('../../../config/wdio/services.default-config');

var _services2 = _interopRequireDefault(_services);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
* Webdriver.io SeleniuMDockerService
* provides standalone chrome/firefox selenium docker automation.
*/
var SeleniumDockerService = function () {
  function SeleniumDockerService() {
    (0, _classCallCheck3.default)(this, SeleniumDockerService);

    this.getSeleniumStatus = this.getSeleniumStatus.bind(this);
  }

  /**
   * Start up docker container before all workers get launched.
   * @param {Object} config wdio configuration object
   * @param {Array.<Object>} capabilities list of capabilities details
   */


  (0, _createClass3.default)(SeleniumDockerService, [{
    key: 'onPrepare',
    value: function () {
      var _ref = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee(config) {
        var dockerInfo;
        return _regenerator2.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                this.config = (0, _extends3.default)({}, _services2.default.seleniumDocker, config.seleniumDocker || {});

                this.host = config.host;
                this.port = config.port;
                this.path = config.path;

                if (!this.config.enabled) {
                  _context.next = 22;
                  break;
                }

                _context.next = 7;
                return this.getDockerInfo();

              case 7:
                dockerInfo = _context.sent;

                if (!(dockerInfo.Swarm.LocalNodeState !== 'active')) {
                  _context.next = 11;
                  break;
                }

                _context.next = 11;
                return this.initSwarm();

              case 11:
                _context.next = 13;
                return this.getStack();

              case 13:
                if (!_context.sent) {
                  _context.next = 18;
                  break;
                }

                _context.next = 16;
                return this.removeStack();

              case 16:
                _context.next = 18;
                return this.ensureNetworkRemoved();

              case 18:
                _context.next = 20;
                return this.deployStack();

              case 20:
                _context.next = 22;
                return this.ensureSelenium();

              case 22:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function onPrepare(_x) {
        return _ref.apply(this, arguments);
      }

      return onPrepare;
    }()

    /**
     * Clean up docker container after all workers got shut down and the process is about to exit.
     */

  }, {
    key: 'onComplete',
    value: function () {
      var _ref2 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee2() {
        return _regenerator2.default.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (!this.config.enabled) {
                  _context2.next = 5;
                  break;
                }

                _context2.next = 3;
                return this.removeStack();

              case 3:
                _context2.next = 5;
                return this.ensureNetworkRemoved();

              case 5:
              case 'end':
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function onComplete() {
        return _ref2.apply(this, arguments);
      }

      return onComplete;
    }()

    /**
    * Waits for selenium to startup and be ready within the configured container.
    * @return {Promise}
    */

  }, {
    key: 'ensureSelenium',
    value: function ensureSelenium() {
      var _this = this;

      return new _promise2.default(function (resolve, reject) {
        console.log('[SeleniumDocker] Ensuring selenium status is ready');
        (0, _retry2.default)({ times: _this.config.retries, interval: _this.config.retryInterval }, _this.getSeleniumStatus, function (err, result) {
          if (err) {
            reject(new Error(err));
          } else {
            resolve(result);
          }
        });
      });
    }

    /**
    * Gets the stack information.
    * @return {Promise} which resolves to a string representing the stack, or null if none exists.
    */

  }, {
    key: 'getStack',
    value: function getStack() {
      return new _promise2.default(function (resolve) {
        (0, _child_process.exec)('docker stack ls | grep wdio', function (error, stdout) {
          resolve(stdout);
        });
      });
    }

    /**
    * Gets information about the docker environment.
    * @return {Promise} which resolves to a JSON object describing the docker environment.
    */

  }, {
    key: 'getDockerInfo',
    value: function getDockerInfo() {
      return this.execute('docker info --format "{{json .}}"').then(function (result) {
        return JSON.parse(result);
      });
    }

    /**
    * Gets the stack default network.
    * @return {Promise} which resolves to a string representing the network, or null if none exists.
    */

  }, {
    key: 'getNetwork',
    value: function getNetwork() {
      return this.execute('docker network ls --filter name=wdio  --format "{{.ID}}: {{.Driver}}"');
    }

    /**
    * Initializes the docker swarm. See https://docs.docker.com/engine/reference/commandline/swarm_init/#related-commands
    * @return {Promise}
    */

  }, {
    key: 'initSwarm',
    value: function initSwarm() {
      console.log('[SeleniumDocker] Initializing docker swarm');
      return this.execute('docker swarm init');
    }

    /**
    * Deploys the docker selenium hub stack
    * @return {Promise}
    */

  }, {
    key: 'deployStack',
    value: function deployStack() {
      console.log('[SeleniumDocker] Deploying docker selenium stack');
      return this.execute('docker stack deploy --compose-file ' + this.config.composeFile + ' wdio');
    }

    /**
    * Stops the docker stack
    * @return {Promise}
    */

  }, {
    key: 'removeStack',
    value: function removeStack() {
      console.log('[SeleniumDocker] Removing docker selenium stack');
      return this.execute('docker stack rm wdio');
    }

    /**
    * Executes an arbitrary command and returns a promise.
    * @param {String} command - The command to execute
    * @return {Promise}
    */

  }, {
    key: 'execute',
    value: function execute(command) {
      return new _promise2.default(function (resolve, reject) {
        (0, _child_process.exec)(command, function (error, stdout) {
          if (error) {
            reject(error);
          } else {
            resolve(stdout);
          }
        });
      });
    }

    /**
    * Ensures the stack default network is removed.
    * @return {Promise}
    */

  }, {
    key: 'ensureNetworkRemoved',
    value: function ensureNetworkRemoved() {
      var _this2 = this;

      return new _promise2.default(function (resolve, reject) {
        (0, _retry2.default)({ times: 1000, interval: 10 }, function (callback) {
          // If there is a network, it will register as an error in the callback
          _this2.getNetwork().then(callback).catch(callback);
        }, function (err, result) {
          if (err) {
            reject(err);
          } else {
            resolve(result);
          }
        });
      });
    }

    /**
    * Gets the status of the selenium server.
    * @param {function} callback taking (err, result).
    */

  }, {
    key: 'getSeleniumStatus',
    value: function getSeleniumStatus(callback) {
      _http2.default.get({
        host: this.host,
        port: this.port,
        path: _path2.default.posix.join(this.path || '/wd/hub', 'status')
      }, function (res) {
        var statusCode = res.statusCode;

        if (statusCode !== 200) {
          callback('Request failed');
          return;
        }

        res.setEncoding('utf8');
        var rawData = '';
        res.on('data', function (chunk) {
          rawData += chunk;
        });
        res.on('end', function () {
          try {
            var status = JSON.parse(rawData);
            if (status.value && status.value.ready) {
              callback(null, status);
            } else {
              callback(status);
            }
          } catch (e) {
            callback('Request failed: ' + e.message);
          }
        });
      }).on('error', function (e) {
        callback('Request failed: ' + e.message);
      });
    }
  }]);
  return SeleniumDockerService;
}(); /* eslint-disable class-methods-use-this, no-console */


exports.default = SeleniumDockerService;